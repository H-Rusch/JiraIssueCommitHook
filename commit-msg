#! /usr/bin/env python3

import os
import re
import sys
import subprocess

BRANCH_ISSUE_KEY_REGEX = re.compile(r".*?/([a-zA-Z]+?-\d+?)[-/].")
COMMIT_ISSUE_KEY_REGEX = re.compile(r"^[A-Z]+?-\d+?:")

COMMIT_MESSAGE_FORMAT = os.environ.get("COMMIT_MESSAGE_FORMAT")


def get_branch_name() -> str:
    completed_process = subprocess.run(
        ["git", "branch", "--show-current"], capture_output=True
    )

    if completed_process.returncode != 0:
        # the git command returns code 128 when HEAD is corrupted
        return ""

    return completed_process.stdout.decode("utf-8").strip()


def find_issue_key(branch_name: str) -> str | None:
    issue_key_match = BRANCH_ISSUE_KEY_REGEX.match(branch_name)
    if issue_key_match is not None:
        return issue_key_match.group(1).upper()


def tag_commit_if_neccessary(commit_msg_filepath: str, issue_key: str):
    with open(commit_msg_filepath, "r+") as file:
        commit_msg = file.read()

        if not is_already_tagged(commit_msg):
            tag_commit_message(file, issue_key, commit_msg)


def is_already_tagged(commit_msg: str) -> bool:
    return COMMIT_ISSUE_KEY_REGEX.match(
        commit_msg
    ) is not None or commit_msg.lower().startswith("no-ticket")


def tag_commit_message(file, issue_key: str, commit_msg: str):
    file.seek(0, 0)
    file.write(format_commit_message(issue_key, commit_msg))


def format_commit_message(issue_key: str, commit_msg: str) -> str:
    return f"{issue_key}: {commit_msg}"


commit_msg_filepath = sys.argv[1]
branch_name = get_branch_name()
issue_key = find_issue_key(branch_name)

if issue_key is not None:
    tag_commit_if_neccessary(commit_msg_filepath, issue_key)
